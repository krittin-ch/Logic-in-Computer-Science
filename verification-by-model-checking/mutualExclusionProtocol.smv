MODULE main
VAR
    pr1 : process prc(pr2.st, turn, TRUE);
    pr2 : process prc(pr1.st, turn, FALSE);
    turn : boolean;
ASSIGN
    init(turn) := FALSE;

-- safety
-- only one process is in its critical section at any time
LTLSPEC G !((pr1.st = c) & (pr2.st = c))

-- liveness
-- whenever any process requests to enter its critical section, it wil eventually br permitted to do so
LTLSPEC G ((pr1.st = t) -> F (pr1.st = c))
LTLSPEC G ((pr2.st = t) -> F (pr2.st = c))

-- 'negation' of strict sequencing (desired to be false)

-- Globally (G)), if pr1.st = c (critical section), then one of the following must be true:
-- [1] pr1.st remains c globally (G pri.st = c), meaning pr1 stays in the critical section indefinitely.
-- [2] There exists a sequence of states (pri.st = c) where pr1.st = c until (U) pr1.st != c and it will
-- never be c again (pr1.st != c & G pr1.st != c), or (|) pr1.st != c until future (F) pr2.st = c.
LTLSPEC G (pr1.st = c -> (G pr1.st = c | (
    pr1.st = c U (pr1.st != c & G pr1.st != c | ((pr1.st != c) U pr2.st = c)))))

MODULE prc(other-st, turn, myturn)
VAR 
    st : {n, t, c};
ASSIGN
    init(st) := n;
    next(st) :=
        case
            (st = n)                                        : {t, n};
            (st = t) & (other-st = n)                       : c;
            (st = t) & (other-st = t) & (turn = myturn)     : c;
            (st = c)                                        : {c, n};
            TRUE : st;
        esac;
    next(turn) :=
        case    
            (turn = myturn) & (st = c)  : !turn;
            TRUE                        : turn;
        esac;
FAIRNESS running
FAIRNESS !(st = c)