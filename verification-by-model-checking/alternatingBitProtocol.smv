MODULE main
VAR 
    s   : process sender(ack_chan.output);                          -- initialize sender
    r   : process receiver(msg_chan.output1, msg_chan.output2);     -- initialize receiver
    msg_chan    : process two-bit-chan(s.message1, s.message2);     -- initialize messages (1 and 2)
    ack_chan    : process one-bit-chan(r.ack);                      -- initialize acknowledgement
ASSIGN
    init(s.message2)    := FALSE;
    init(r.expected)    := FALSE;
    init(r.ack)         := TRUE;
    init(msg_chan.output2)  := TRUE;
    init(ack_chan.output)   := TRUE;
LTLSPEC
    -- Safety: If the message bit 1 has been sent and the correct acknowledgement has been returned,
    -- then a 1 was indeed reeived by the receiver
    G ( (s.st = sent & s.message1 = TRUE) -> msg_chan.output1 = TRUE)

MODULE sender(ack)
VAR
    st          : {sending, sent};  -- sending/sent status
    message1    : boolean;          -- the current bit of the message being sent
    message2    : boolean;          -- the control bit 
ASSIGN
    init(st) := sending;
    next(st) :=
        case
            ack = message2 & (st != sent)   : sent;
            TRUE                            : sending;
        esac;
    
    next(message1) := 
        case
            st = sent   : {FALSE, TRUE};
            TRUE        : message1;
        esac;

    next(message2) := 
        case
            st = sent   : !message2;
            TRUE        : message2;
        esac;
FAIRNESS running
LTLSPEC
    -- Liveness: Messages get through eventually.
    -- Thus, for any state there is inevitably a future state in which the curretn message has got through.
    -- In the module "sender", we specified LTLSPEC : G F st = sent.
    -- Similarily, acknowledgement get through eventually. In the module "receiver", we wrote LTLSPEC : G F st = received.
    G F st = sent

MODULE receiver(message1, message2)
VAR
    st          : {recieving, recieved};  -- recieving/recieved status
    ack         : boolean;          -- 
    expected    : boolean;          --  
ASSIGN
    init(st) := recieving;
    next(st) :=
        case
            message2 = expected & (st != recieving) : recieved;
            TRUE                                    : recieving;
        esac;
    
    next(ack) := 
        case
            st = recieved   : message2;
            TRUE            : ack;
        esac;

    next(expected) := 
        case
            st = recieved   : !expected;
            TRUE            : expected;
        esac;
FAIRNESS running
LTLSPEC
    -- Liveness: Messages get through eventually.
    G F st = recieved

MODULE one-bit-chan(input)
VAR 
    output : boolean;
    forget : boolean;   -- determines whether the current bit is lost or not
ASSIGN
    next(output) :=
        case
            forget  : output;
            TRUE    : input;
        esac;
FAIRNESS running
FAIRNESS input & !forget
FAIRNESS !input & !forget

MODULE two-bit-chan(input1, input2)
VAR
    forget  : boolean;
    output1 : boolean;
    output2 : boolean;
ASSIGN
    next(output1) := 
        case
            forget  : output1;
            TRUE    : input1;
        esac;

    next(output2) := 
        case
            forget  : output2;
            TRUE    : input2;
        esac;
FAIRNESS running
FAIRNESS input1 & !forget
FAIRNESS !input1 & !forget
FAIRNESS input2 & !forget
FAIRNESS !input2 & !forget
